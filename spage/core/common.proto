syntax = "proto3";

package spage.core;

option go_package = "github.com/AlexanderGrooff/spage-protobuf/spage/core";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
// NOTE: Avoid importing plays.proto here to prevent circular imports.

// Error represents an error response
message Error {
  string code = 1;
  string message = 2;
  map<string, string> details = 3;
}

// HealthStatus represents the health status of a component
message HealthStatus {
  string status = 1; // "healthy", "unhealthy", "degraded"
  string message = 2;
  map<string, string> details = 3;
  google.protobuf.Timestamp timestamp = 4;
}

// TaskStatus represents the status of a task
enum TaskStatus {
  TASK_STATUS_UNSPECIFIED = 0;
  TASK_STATUS_PENDING = 1;
  TASK_STATUS_RUNNING = 2;
  TASK_STATUS_COMPLETED = 3;
  TASK_STATUS_FAILED = 4;
  TASK_STATUS_CANCELED = 5;
  TASK_STATUS_SKIPPED = 6;
}

// SpageTask represents a task with all its metadata
message SpageTask {
  int32 id = 1;
  string name = 2;
  TaskStatus status = 3;
  google.protobuf.Timestamp created_at = 4;
  google.protobuf.Timestamp updated_at = 5;
  google.protobuf.Timestamp started_at = 6;
  google.protobuf.Timestamp completed_at = 7;
  // Optional textual output and error summary for the task
  string output = 8;
  string error = 9;
}

message TaskMetrics {
  double duration = 1; // Duration in seconds
  double memory_alloc = 2; // Memory allocated in bytes
  double memory_heap = 3; // Memory heap in bytes
  double memory_sys = 4; // Memory system in bytes
  double memory_heap_sys = 5; // Memory heap system in bytes
  double gc_cycles = 6; // Garbage collection cycles
  double goroutines = 7; // Goroutines
  double cpu_count = 8; // CPU count
}

// TaskResult represents the result of a task execution
message TaskResult {
  int32 task_id = 1;
  string task_name = 2;
  TaskStatus status = 3;
  string output = 4;
  string error = 5;
  TaskMetrics metrics = 6;
  google.protobuf.Timestamp started_at = 7;
  google.protobuf.Timestamp completed_at = 8;
}

message TaskProgressUpdate {
  string play_id = 1;
  int32 task_id = 2;
  string task_name = 3;
  TaskResult result = 4;
  google.protobuf.Timestamp timestamp = 5;
}

// ===== Messaging (Commands and Events) =====

// Envelope for daemon control commands
message CommandEnvelope {
  string correlation_id = 1;
  string daemon_id = 2;
  oneof body {
    StartSpageRequest start = 10;
    CancelPlayRequest cancel = 11;
    PingRequest ping = 12;
  }
}

message StartSpageRequest {
  string play_id = 1;
  string playbook = 2;
  string inventory = 3;
  map<string, string> variables = 4;
  // Optional runtime configuration to control Spage behavior
  SpageRunConfig config = 5;
}

message CancelPlayRequest {
  string play_id = 1;
  string reason = 2;
}

message PingRequest {}

message CommandResultEvent {
  string correlation_id = 1;
  string verb = 2; // start, cancel, ping
  string play_id = 3;
  bool success = 4;
  string error = 5;
  google.protobuf.Timestamp timestamp = 6;
}

// Telemetry events (task-level; play/metrics events are in events.proto to avoid cycles)
message TaskEvent {
  string play_id = 1;
  SpageTask task = 2;
}

// ===== Run-time configuration passed with StartSpageRequest =====
message LoggingConfig {
  string level = 1;
  string file = 2;
  string format = 3; // "json" | "yaml" | "plain"
  bool timestamps = 4;
}

message TemporalConfig {
  string address = 1;
  string task_queue = 2;
  string workflow_id_prefix = 3;
  bool trigger = 4;
}

message APIConfig {
  string http_base = 1;
}

message DaemonConfig {
  bool enabled = 1;
  string endpoint = 2;
  string play_id = 3;
  int64 timeout_ms = 4; // duration in milliseconds
}

message TagsConfig {
  repeated string tags = 1;
  repeated string skip_tags = 2;
}

message PrivilegeEscalationConfig {
  bool use_interactive = 1; // -Su vs -u
  string become_flags = 2;  // additional flags
}

message SpageRunConfig {
  LoggingConfig logging = 1;
  string execution_mode = 2; // "parallel" | "sequential"
  string executor = 3;       // "local" | "temporal"
  TemporalConfig temporal = 4;
  APIConfig api = 5;
  DaemonConfig daemon = 6;
  bool revert = 7;
  TagsConfig tags = 8;
  google.protobuf.Struct facts = 9; // arbitrary key/value facts
  bool host_key_checking = 10;
  string roles_path = 11;           // colon-delimited
  string inventory = 12;            // optional override
  PrivilegeEscalationConfig privilege_escalation = 13;
  string api_token = 14;            // bearer token for CLI auth
}

// Enrollment over NATS
message EnrollRequest {
  string daemon_id = 1;
  string hostname = 2;
  string version = 3;
  map<string, string> capabilities = 4;
}

message EnrollReply {
  bool success = 1;
  string error = 2;
  // NATS creds content (JWT + NKey seed), PEM-like blocks
  string creds = 3;
}

// ===== Device Code Enrollment (OAuth-style) =====
enum DeviceEnrollStatus {
  DEVICE_ENROLL_PENDING = 0;
  DEVICE_ENROLL_APPROVED = 1;
  DEVICE_ENROLL_DENIED = 2;
  DEVICE_ENROLL_EXPIRED = 3;
}

message DeviceEnrollBeginRequest {
  string hostname = 1;
  string version = 2;
}

message DeviceEnrollBeginReply {
  string device_code = 1;                 // secret for polling
  string user_code = 2;                   // human-friendly code to enter in browser
  string verification_uri = 3;            // base URL where user enters the code
  string verification_uri_complete = 4;   // full URL with code embedded (optional)
  int32 expires_in = 5;                   // seconds
  int32 interval = 6;                     // recommended poll interval seconds
}

message DeviceEnrollPollRequest {
  string device_code = 1;
}

message DeviceEnrollPollReply {
  DeviceEnrollStatus status = 1;
  string error = 2;
  string daemon_id = 3;
  string creds = 4; // NATS creds when approved
}
